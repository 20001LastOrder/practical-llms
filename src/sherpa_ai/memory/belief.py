from __future__ import annotations

from typing import TYPE_CHECKING, Callable, List, Optional

import pydash
import transitions as ts
from loguru import logger

from sherpa_ai.events import Event, build_event

if TYPE_CHECKING:
    from sherpa_ai.actions.base import BaseAction
    from sherpa_ai.memory.state_machine import SherpaStateMachine


class Belief:
    """
    The belief of the agent. it contains
        1. events: the events observed by the agent, synchronized with the shared memory
        2. internal_events: the internal events generated by the agent through its reasoning process (actions)
    """  # noqa E501

    def __init__(self):
        self.events: List[Event] = []
        self.internal_events: List[Event] = []
        self.current_task: Event = None
        self.state_machine: SherpaStateMachine = None
        self.actions = []
        self.dict: dict = {}
        self.max_tokens = 4000

    def update(self, observation: Event):
        if observation in self.events:
            return

        self.events.append(observation)

    def get_context(self, token_counter: Callable[[str], int]):
        """
        Get the context of the agent

        Args:
            token_counter: Token counter
            max_tokens: Maximum number of tokens

        Returns:
            str: Context of the agent
        """
        context = ""
        for event in reversed(self.events):
            if event.event_type in [
                "task",
                "result",
                "user_input",
            ]:
                message = f"{event.name}: {event.content}({event.event_type})"
                context = message + "\n" + context

                if token_counter(context) > self.max_tokens:
                    break

        return context

    def update_internal(self, event_type: str, name: str, **kwargs):
        event = build_event(event_type, name, **kwargs)
        self.internal_events.append(event)

    def get_by_type(self, event_type):
        return [
            event for event in self.internal_events if event.event_type == event_type
        ]

    def get_events_by_type(self, event_type: str, token_counter: Optional[Callable[[str], int]] = None, max_tokens: Optional[int] = None) -> List[dict]:
        """Retrieve events of a specific type as JSON objects.

        This function filters the internal events based on the specified event type and converts
        each matching event to a JSON-compatible dictionary using Pydantic's model_dump() method.
        The function is useful for processing specific types of events in a structured format.

        Args:
            event_type (str): The type of events to retrieve (e.g., "action_start", "feedback").
            token_counter (Optional[Callable[[str], int]]): Function to count tokens in a string.
                If None, no token limiting is applied.
            max_tokens (Optional[int]): Maximum number of tokens to include in the result.
                If None, no token limiting is applied.

        Returns:
            List[dict]: A list of events as JSON objects, where each object contains the event's
                properties (name, content, event_type, etc.). If token_counter and max_tokens are
                provided, the result is limited by token count.

        Example:
            >>> belief = Belief()
            >>> belief.update_internal("action_start", "test_action", args={"param": "value"})
            >>> events = belief.get_events_by_type("action_start")
            >>> print(events[0]["name"])
            test_action
            
            # With token limiting
            >>> events = belief.get_events_by_type("action_start", max_tokens=100)
            >>> print(len(events))  # Will be limited by token count
        """
        if token_counter is None or max_tokens is None:
            # If no token counter or max_tokens is provided, return all events of the specified type
            return [event.model_dump() for event in self.internal_events if event.event_type == event_type]
        
        # if no token counter is provided, use the default word counter
        if token_counter is None:
            def token_counter(x):
                return len(x.split())
                
        results = []
        current_tokens = 0
        
        for event in reversed(self.internal_events):
            if event.event_type == event_type:
                event_dict = event.model_dump()
                event_str = str(event)
                results.append(event_dict)
                current_tokens += token_counter(event_str)
                if current_tokens > max_tokens:
                    break
                    
        return list(reversed(results))

    def get_events_excluding_types(self, exclude_types: List[str], token_counter: Optional[Callable[[str], int]] = None, max_tokens: Optional[int] = None) -> List[dict]:
        """Retrieve events excluding specific types as JSON objects.

        This function filters out events whose types are in the exclude_types list and converts
        the remaining events to JSON-compatible dictionaries. It's useful for getting a subset
        of events while excluding certain event types from the results.

        Args:
            exclude_types (List[str]): List of event types to exclude from the results
                (e.g., ["feedback", "action_start"]).
            token_counter (Optional[Callable[[str], int]]): Function to count tokens in a string.
                If None, no token limiting is applied.
            max_tokens (Optional[int]): Maximum number of tokens to include in the result.
                If None, no token limiting is applied.

        Returns:
            List[dict]: A list of events as JSON objects, excluding events whose types are
                in the exclude_types list. Each object contains the event's properties.
                If token_counter and max_tokens are provided, the result is limited by token count.

        Example:
            >>> belief = Belief()
            >>> belief.update_internal("action_start", "action1", args={})
            >>> belief.update_internal("feedback", "feedback1", content="good")
            >>> events = belief.get_events_excluding_types(["feedback"])
            >>> print(events[0]["event_type"])
            action_start
            
            # With token limiting
            >>> events = belief.get_events_excluding_types(["feedback"], max_tokens=100)
            >>> print(len(events))  # Will be limited by token count
        """
        if token_counter is None or max_tokens is None:
            # If no token counter or max_tokens is provided, return all events excluding the specified types
            return [event.model_dump() for event in self.internal_events if event.event_type not in exclude_types]
        
        # if no token counter is provided, use the default word counter
        if token_counter is None:
            def token_counter(x):
                return len(x.split())
                
        results = []
        feedback = []
        current_tokens = 0
        
        for event in reversed(self.internal_events):
            if event.event_type not in exclude_types:
                event_dict = event.model_dump()
                event_str = str(event)
                
                if event.event_type == "feedback":
                    feedback.append(event_dict)
                else:
                    results.append(event_dict)
                    
                current_tokens += token_counter(event_str)
                if current_tokens > max_tokens:
                    break
                    
        return list(reversed(results)) + list(reversed(feedback))

    def set_current_task(self, content):
        event = build_event("task", "current_task", content=content)
        self.current_task = event

    def get_internal_history(self, token_counter: Callable[[str], int]):
        """
        Get the internal history of the agent

        Args:
            token_counter: Token counter

        Returns:
            str: Internal history of the agent with event content separated by newlines.
            History is truncated if the number of tokens exceeds `max_tokens`.
        """
        results = []
        current_tokens = 0

        for event in reversed(self.internal_events):
            event_str = str(event)
            results.append(event_str)
            current_tokens += token_counter(event_str)
            if current_tokens > self.max_tokens:
                break

        context = "\n".join(reversed(results))
        return context

    def clear_short_term_memory(self):
        self.dict.clear()
        self.internal_events.clear()

    def get_histories_excluding_types(
        self,
        exclude_types: list[str],
        token_counter: Optional[Callable[[str], int]] = None,
        max_tokens=4000,
    ):
        """
            Get the internal history of the agent without events of excluded_type

        Args:
            token_counter: Token counter
            max_tokens: Maximum number of tokens
            exclude_types: List of events to be excluded

        Returns:
            str: Internal history of the agent with event content separated by newlines.
            History is truncated if the number of tokens exceeds `max_tokens`.
        """
        if token_counter is None:
            # if no token counter is provided, use the default word counter
            def token_counter(x):
                return len(x.split())

        results = []
        feedback = []
        current_tokens = 0
        for event in reversed(self.internal_events):
            if event.event_type not in exclude_types:
                if event.event_type == "feedback":
                    feedback.append(str(event))
                else:
                    results.append(str(event))
            current_tokens += token_counter(str(event))
            if current_tokens > max_tokens:
                break
        context = "\n".join(set(reversed(results))) + "\n".join(set(feedback))
        return context

    def set_actions(self, actions: List[BaseAction]):
        if self.state_machine is not None:
            logger.warning(
                "State machine exists, please add actions as transitions directly to the state machine"  # noqa E501
            )
            return

        self.actions = actions

        # TODO: This is a quick an dirty way to set the current task
        # in actions, need to find a better way
        for action in actions:
            if action.__class__.__name__ == "BaseRetrievalAction":
                action.current_task = self.current_task.content

    @property
    def action_description(self):
        return "\n".join([str(action) for action in self.get_actions()])

    def get_state(self) -> str:
        if self.state_machine is None:
            return None

        return self.state_machine.get_current_state().name

    def get_state_obj(self) -> ts.State:
        if self.state_machine is None:
            return None

        return self.state_machine.get_current_state()

    def get_actions(self) -> List[BaseAction]:
        if self.state_machine is None:
            return self.actions

        return self.state_machine.get_actions()

    def get_action(self, action_name) -> BaseAction:
        if self.state_machine is not None:
            self.actions = self.state_machine.get_actions()

        result = None
        for action in self.actions:
            if action.name == action_name:
                result = action
                break
        return result

    async def async_get_actions(self) -> List[BaseAction]:
        if self.state_machine is None:
            return self.actions

        return await self.state_machine.async_get_actions()

    async def async_get_action(self, action_name) -> BaseAction:
        if self.state_machine is not None:
            self.actions = await self.state_machine.async_get_actions()

        result = None
        for action in self.actions:
            if action.name == action_name:
                result = action
                break
        return result

    def get_dict(self):
        return self.dict

    def get(self, key, default=None):
        """
        Get value from the dict, the key can be a dot separated string if the value is nested
        """  # noqa E501
        return pydash.get(self.dict, key, default)

    def get_all_keys(self):
        def get_all_keys(d, parent_key=""):
            keys = []
            for k, v in d.items():
                full_key = parent_key + "." + k if parent_key else k
                keys.append(full_key)
                if isinstance(v, dict):
                    keys.extend(get_all_keys(v, full_key))
            return keys

        return get_all_keys(self.dict)

    def has(self, key):
        """
        Check if the key exists in the dict
        """
        return pydash.has(self.dict, key)

    def set(self, key, value):
        """
        Set value in the dict, the key can be a dot separated string if the value is nested
        """  # noqa E501
        pydash.set_(self.dict, key, value)

    @property
    def __dict__(self):
        return {
            "events": [event.__dict__ for event in self.events],
            "internal_events": [event.__dict__ for event in self.internal_events],
            "current_task": self.current_task.__dict__ if self.current_task else None,
            "dict": self.dict,
        }

    @classmethod
    def from_dict(cls, data):
        belief = cls()
        belief.events = [Event.from_dict(event) for event in data["events"]]
        belief.internal_events = [
            Event.from_dict(event) for event in data["internal_events"]
        ]
        belief.current_task = (
            Event.from_dict(data["current_task"]) if data["current_task"] else None
        )

        belief.dict = data["dict"]

        return belief
